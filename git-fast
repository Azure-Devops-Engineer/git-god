#!/usr/bin/ruby
require 'find'
require 'tempfile'
require 'set'

CONFIG_FILE = ".git-fast"
TEMP_CONFIG = "temp.git-fast"
LOGGED = "logged"
DEFAULT_START_LOG = "["
DEFAULT_END_LOG = "]"
ADD = "add"
ALL = "all"
PUSH_ORIGIN = "push_origin"
ISSUE = "issue"
CURRENT_ISSUE = "current_issue"
ISSUE_DELIMITER = "->"

LOG_PRIORITY = 0
ADD_PRIORITY = 1
PUSH_ORIGIN_PRIORITY = 2
CURRENT_PRIORITY = 3

def handleLog(args, index)
  defaultDelimiter = true
  start_del = DEFAULT_START_LOG
  end_del = DEFAULT_END_LOG

  if args.length == 1 then
    showNoLogIncludedError()
  end

  args.each_with_index do |arg, i|
    arg_spl = arg.split("=")
    case arg_spl[0]
    when "--del"

      if args.length == 2 then
        showNoLogIncludedError()
      end

      if arg_spl.length == 1 then
        showDelimiterNotIncludedError()
      end

      # only one character provided, use for both
      if arg_spl[1].length == 1 then
        log(args, i, arg_spl[1][0], arg_spl[1][0])
        return
      elsif arg_spl[1].length == 2 then
        log(args, i, arg_spl[1][0], arg_spl[1][1])
        return
      else
        showInvalidDelimiterError()
      end
    end
  end

  log(args, index, start_del, end_del)
end

def showNoLogIncludedError()
  puts "Error: no logs have been included."
  exit(128)
end

def showDelimiterNotIncludedError()
  puts "Error: delimiter is empty or it is invalid."
  toAddDelimiterTut()
end

def showInvalidDelimiterError()
  puts "Error: invalid delimiter supplied for log."
  toAddDelimiterTut()
end

def toAddDelimiterTut()
  puts "To add a delimiter, add flag --del=\"<delimiter>\". Note the double quotes."
  puts "<delimiter> must be one or two characters."
  exit(128)
end

def log(args, index, start_del, end_del)
  # find the previous logged info
  logUsers = ""
  file = openConfigFile()

  args[index + 1..-1].each do |arg|
    puts "Logged: #{arg}"
    logUsers += start_del + arg + end_del
  end

  writeToFileOrOverwrite(LOGGED, "#{LOGGED}=#{logUsers}")
  file.close
end

def isConfigFile(name)
  File.basename(name) == CONFIG_FILE
end

def writeToFileOrOverwrite(flag, newValue)
  tmp_file = Tempfile.new(TEMP_CONFIG)
  file = openConfigFile()
  hasBeenWritten = false
  begin
    file.each_line do |line|
      if line.split("=")[0] == flag then
      # overwrite
      hasBeenWritten = true
      tmp_file.puts(newValue)
      else
      tmp_file.puts(line)
      end
    end

  # no line exists
  if not hasBeenWritten then
    tmp_file.puts(newValue)
  end
  tmp_file.close
  # change the name and overwrite
  FileUtils.mv(tmp_file, file)
  file.close
ensure
  tmp_file.close
  tmp_file.unlink
  file.close
end
end

def writeToFile(file_name, value)
  #assumes file is not opened
  file = File.open(file_name, "a")
  file.puts(value)
  file.close
end

def deleteLineWithKey(key)
  tmp_file = Tempfile.new(TEMP_CONFIG)
  file = openConfigFile()
  begin
    file.each_line do |line|
      next if line.split("=")[0] == key
      tmp_file.puts(line)
    end
  tmp_file.close
  # change the name and overwrite
  FileUtils.mv(tmp_file, file)
  file
  ensure
  tmp_file.close
  tmp_file.unlink
  file.close
  end
end

def existsConfigFile()
Find.find(Dir.pwd) do |e|
  next if File.directory?(e)
  if isConfigFile(e) then return true end
end
false
end

def removeConfig(args, index)
  configFile = openConfigFile()
  shouldDeleteCurrentIssue = false
  if args.length == 1 then
    # flag is only -r, delete whole configuration
  if File.exist?(CONFIG_FILE) then File.delete(CONFIG_FILE) end
  else
    # delete specific attributes
    args[index + 1..-1].each do |flag|
      key = getKeyFromFlag(flag)
      # would delete all issues in case key is issue
      if key == ISSUE then shouldDeleteCurrentIssue = true end
      file = deleteLineWithKey(key)
      configFile = file
    end
  end

  # if all issues are deleted then also delete the current issue symbol
  if shouldDeleteCurrentIssue then deleteLineWithKey(CURRENT_ISSUE) end
  configFile.close
end

def showStatus()
  info = Hash.new
  issues = Set.new
  configFile = openConfigFile()
  configFile.each_line do |line|
    line_array = line.split("=")
    case line_array[0]
    when LOGGED
      info[LOG_PRIORITY] = line_array[1..-1]
    when ADD
      info[ADD_PRIORITY] = line_array[1..-1]
    when PUSH_ORIGIN
      info[PUSH_ORIGIN_PRIORITY] = line_array[1..-1]
    when ISSUE
      issues << line_array[1..-1]
    when CURRENT_ISSUE
      info[CURRENT_PRIORITY] = line_array[1..-1]
    end
  end

  configFile.close

  info = Hash[info.sort]
  info.each do |k, v|
    case k
    when LOG_PRIORITY
      puts "logged: #{v[0]}"
    when ADD_PRIORITY
      if v[0].length != 0 then puts "add: " + ALL end
    when PUSH_ORIGIN_PRIORITY
      puts "pushing to: #{v[0]}"
    when CURRENT_PRIORITY
      puts "current issue: #{v[0]}"
    end
  end

  # if there is no current issue because it has been restored or never assigned
  if info[CURRENT_PRIORITY] == nil then puts "no current issues" end

  issues.each do |issue_line|
    if issue_line.length == 1 then
      puts "issue: #{issue_line[0]}"
    else
      puts "issue: #{issue_line[0]}, alias: #{issue_line[1]}"
    end
  end

end

def getValues()
  info = Hash.new
  issues = Set.new
  configFile = openConfigFile()
  configFile.each_line do |line|
    line_array = line.strip.split("=")
    if line_array[0] == ISSUE then
      # case when it is an issue, need to track name and alias
      aliasForName = ""
      if line_array[2] != nil then aliasForName = line_array[2] end
      issues << line_array[1] + "=" + aliasForName
    else
    info[line_array[0]] = line_array[1]
    end
  end
  return info, issues
end

def openConfigFile()
  File.open(CONFIG_FILE, "r+")
end

def commit(args, index, flag)
  values, issues = getValues()
  logUsers = values[LOGGED]
  issue = values[CURRENT_ISSUE]

  if args.length != 2 then showInvalidSizeCommit(flag) end

  message = ""

  if isDefined(logUsers) then
    message += logUsers
  end

  if isDefined(issue) then
    message += ISSUE_DELIMITER + issue
  end

  message += " " + args[1].to_s

  addAtts = values[ADD]
  if isDefined(addAtts) then
    puts "adding all"
    # puts `git add -A`
  end
  puts "commiting..."
  puts "#{message}"
  # puts `git commit -m \"#{message}\"`
end


def push(args, index)
  values, issues = getValues()
  pushAtts = values[PUSH_ORIGIN]
  if not isDefined(pushAtts) then
    puts "pushing normal"
    # puts `git push`
  else
    puts "pushing origin #{pushAtts}"
    # puts `git push origin #{branch}`
  end
end

def pushAtts(args, index)
  if args.length == 1 then
    showPushAttsWithNoAttsError()
  end

  args[1..-1].each do |value|
    value_spl = value.split("=")
    if value_spl.length == 1 then showPushAttsWithNoAttsError end
    case value_spl[0]
    when "--o"
      writeToFileOrOverwrite(PUSH_ORIGIN, "#{PUSH_ORIGIN}=#{value_spl[1]}")
    end
  end
end

def showInvalidSizeCommit(callingFlag)
  puts "Error: trying to commit but incorrect number of arguments supplied."
  puts "Expected: git-fast #{callingFlag} \"<some message>\""
  exit(128)
end

def showPushAttsWithNoAttsError()
  puts "Error: trying to add a configuration for push but no attributes are found."
  puts "To add a configuration for push, use \"git-fast -p --o=<branch-name>\"."
  puts "This is the equivalent of \"git push origin branch-name\"."
  exit(128)
end

def isDefined(val)
  val != nil
end

def alwaysAddAll()
  writeToFileOrOverwrite(ADD, "#{ADD}=#{ALL}")
end

def getKeyFromFlag(flag)
  if not isConfigurable(flag) then
    puts "Error: configuration for #{flag} cannot be removed."
    puts "The flag #{flag} is non configurable or does not exist."
    exit(128)
  end
  case flag
  when "-l"
    LOGGED
  when "-p"
    PUSH_ORIGIN
  when "-a"
    ADD
  when "-i"
    ISSUE
  end
end

def isConfigurable(flag)
  flag == "-l" or flag == "-p" or flag == "-a" or flag == "-i"
end

def issue(args, index)
  if not correctIssueArgLength(args) then showIncorrectIssueArgLengthError(args.length) end
  # if length is one, then we want to commit without issue
  if args.length == 1 then
    deleteLineWithKey(CURRENT_ISSUE)
    exit(0)
  end
  name = ""
  aliasForName = nil

  args[index + 1..-1].each do |arg|
    arg_spl = arg.split("=")
    case arg_spl[0]
    when "--name"
      name = arg_spl[1]
    when "--alias"
      aliasForName = arg_spl[1]
    else
      values, issues = getValues()
      if arg_spl[0][1..-1] == values[CURRENT_ISSUE] then
        exit(0)
      end
      # it must be an alias or name
      name = getNameFromAlias(arg_spl[0][1..-1].strip)
      if name == nil then showErrorIssueDoesNotExist(arg_spl[0][1..-1]) end
      writeToFileOrOverwrite(CURRENT_ISSUE, "#{CURRENT_ISSUE}=#{name}")
      puts "Current issue: #{name}"
      exit(0) # job is done, no need to add any issues
    end
  end

  if name == nil then showNoNameForIssueError end

  # writeToFile leaves configFile closed
  if aliasForName == nil then
    writeToFileOrOverwrite(CURRENT_ISSUE, "#{CURRENT_ISSUE}=#{name}")
    writeToFile(CONFIG_FILE, "#{ISSUE}=#{name}")
  else
    writeToFileOrOverwrite(CURRENT_ISSUE, "#{CURRENT_ISSUE}=#{name}=#{aliasForName}")
    writeToFile(CONFIG_FILE, "#{ISSUE}=#{name}=#{aliasForName}")
  end

end

def getNameFromAlias(aliasOrName)
  configFile = openConfigFile()
  begin
    configFile.each_line do |line|
      line_spl = line.strip.split("=")
      next if line_spl[0] != ISSUE
      # line is an issue
      if aliasOrName == line_spl[1] or aliasOrName == line_spl[2] then
        return line_spl[1]
      end
    end
    # if not found return nil
    nil
  ensure
    configFile.close
  end
end

def showErrorIssueDoesNotExist(name)
  puts "Error: issue with name #{name} or alias #{name} does not exist."
  expectedForIssue()
end

def correctIssueArgLength(args)
  args.length >= 1 and args.length <= 3
end

def showNoNameForIssueError()
  puts "Error: no name was supplied for a new issue."
  expectedForIssue()
end

def showIncorrectIssueArgLengthError(len)
  puts "Error: Creating a new issue expects a name and an optional alias."
  expectedForIssue()
end

def expectedForIssue()
  puts "Expected: \"git-fast -i --name=<issue-name>\" or \"git-fast -i --name=<issue-name> --alias=<alias>\"."
  puts "To set the current issue, use \"git-fast -i -<alias or name of issue>\"."
  exit(128)
end

def unsupportedCommand(arg)
  puts "Error: unexpected command \"#{arg}\" found."
  puts "To view a full list of all arguments to git-fast, run git-fast --commands."
end

def printCommands()
  puts ""
  puts "List of commands in git-fast:"
  puts ""
  puts "git-fast -a"
  puts "git-fast -c"
  puts "git-fast --commands"
  puts "git-fast -cpf"
  puts "git-fast -i"
  puts "git-fast -l"
  puts "git-fast -p"
  puts "git-fast -pf"
  puts "git-fast -r"
  puts "git-fast [-s|status]"
  puts ""
end

# create configuration file if it doesnt exist
if not File.exist?(CONFIG_FILE) then
  configFile = File.open(CONFIG_FILE, "w+")
  configFile.close
end

arg = ARGV[0]
index = 0
case arg
when "-l"
  handleLog(ARGV, index)
when "-c"
  commit(ARGV, index, "-c")
when "-p"
  pushAtts(ARGV, index)
when "-pf"
  # force push, no addition of attributes, with attributes from config file
  push(ARGV, index)
when "-cpf"
  commit(ARGV, index, "-cpf")
  push(ARGV, index)
when "-r"
  removeConfig(ARGV, index)
when "status", "-s"
  showStatus()
when "-a"
  alwaysAddAll()
when "-i"
  issue(ARGV, index)
when "--commands"
  printCommands()
else
  unsupportedCommand(arg)
end
