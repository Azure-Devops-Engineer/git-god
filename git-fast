#!/usr/bin/ruby
require 'find'
require 'tempfile'

CONFIG_FILE = ".git-fast"
TEMP_CONFIG = "temp.git-fast"
LOGGED = "logged"
LOG_PRIORITY = 0
DEFAULT_START_LOG = "["
DEFAULT_END_LOG = "]"
ADD = "add"
ADD_PRIORITY = 1
ALL = "all"
PUSH_ORIGIN = "push_origin"
PUSH_ORIGIN_PRIORITY = 2

def handleLog(args, index, file)
  defaultDelimiter = true
  start_del = DEFAULT_START_LOG
  end_del = DEFAULT_END_LOG

  if args.length == 1 then
    showNoLogIncludedError()
  end

  args.each_with_index do |arg, i|
    arg_spl = arg.split("=")
    case arg_spl[0]
    when "--del"

      if args.length == 2 then
        showNoLogIncludedError()
      end

      if arg_spl.length == 1 then
        showDelimiterNotIncludedError()
      end

      # only one character provided, use for both
      if arg_spl[1].length == 1 then
        log(args, i, file, arg_spl[1][0], arg_spl[1][0])
        return
      elsif arg_spl[1].length == 2 then
        log(args, i, file, arg_spl[1][0], arg_spl[1][1])
        return
      else
        showInvalidDelimiterError()
      end
    end
  end

  log(args, index, file, start_del, end_del)
end

def showNoLogIncludedError()
  puts "Error: no logs have been included."
  exit(128)
end

def showDelimiterNotIncludedError()
  puts "Error: delimiter is empty or it is invalid."
  toAddDelimiterTut()
end

def showInvalidDelimiterError()
  puts "Error: invalid delimiter supplied for log."
  toAddDelimiterTut()
end

def toAddDelimiterTut()
  puts "To add a delimiter, add flag --del=\"<delimiter>\". Note the double quotes."
  puts "<delimiter> must be one or two characters."
  exit(128)
end

def log(args, index, file, start_del, end_del)
  # find the previous logged info
  logUsers = ""

  args[index + 1..-1].each do |arg|
    puts "Logged: #{arg}"
    logUsers += start_del + arg + end_del
  end

  writeToFileOrOverwrite(file, LOGGED, "#{LOGGED}=#{logUsers}")
end

def isConfigFile(name)
  File.basename(name) == CONFIG_FILE
end

def writeToFileOrOverwrite(file, flag, newValue)
  tmp_file = Tempfile.new(TEMP_CONFIG)
  hasBeenWritten = false
  begin
    file.each_line do |line|
      if line.split("=")[0] == flag then
      # overwrite
      hasBeenWritten = true
      tmp_file.puts(newValue)
    else
      tmp_file.puts(line)
    end
  end

  # no line exists
  if not hasBeenWritten then
    tmp_file.puts(newValue)
  end
  tmp_file.close
  # change the name and overwrite
  FileUtils.mv(tmp_file, file)
ensure
  tmp_file.close
  tmp_file.unlink
end
end

def deleteLineWithKey(file, key)
  tmp_file = Tempfile.new(TEMP_CONFIG)
  begin
    file.each_line do |line|
      next if line.split("=")[0] == key
      tmp_file.puts(line)
    end
  tmp_file.close
  # change the name and overwrite
  FileUtils.mv(tmp_file, file)
  file
  ensure
  tmp_file.close
  tmp_file.unlink
  end
end

def existsConfigFile()
Find.find(Dir.pwd) do |e|
  next if File.directory?(e)
  if isConfigFile(e) then return true end
end
false
end

def removeConfig(args, index, configFile)
  if args.length == 1 then
    # flag is only -r, delete whole configuration
  if File.exist?(CONFIG_FILE) then File.delete(CONFIG_FILE) end
  else
    # delete specific attributes
    args[index + 1..-1].each do |flag|
      key = getKeyFromFlag(flag)
      file = deleteLineWithKey(configFile, key)
      configFile = file
    end
  end
end

def showStatus(configFile)
  info = Hash.new
  configFile.each_line do |line|
    line_array = line.split("=")
    case line_array[0]
    when LOGGED
      info[LOG_PRIORITY] = line_array[1..-1]
    when ADD
      info[ADD_PRIORITY] = line_array[1..-1]
    when PUSH_ORIGIN
      info[PUSH_ORIGIN_PRIORITY] = line_array[1..-1]
    end
  end

  info = Hash[info.sort]
  info.each do |k, v|
    case k
    when LOG_PRIORITY
      puts "logged: #{v[0]}"
    when ADD_PRIORITY
      if v[0].length != 0 then puts "add " + ALL end
    when PUSH_ORIGIN_PRIORITY
      puts "pushing to: #{v[0]}"
    end
  end
end

def getValues(configFile)
  info = Hash.new
  configFile.each_line do |line|
    line_array = line.split("=")
    info[line_array[0]] = line_array[1]
  end
  info
end

def commit(args, index, configFile)
  values = getValues(configFile)
  logUsers = values[LOGGED]

  if not isDefined(logUsers) then
    message = ""
  else
    message = logUsers + " " + args[1].to_s
  end

  addAtts = values[ADD]
  if isDefined(addAtts) then
    puts "adding all"
    # puts `git add -A`
  end
  puts "commiting..."
  # puts `git commit -m \"#{message}\"`
end


def push(args, index, configFile)
  values = getValues(configFile)
  pushAtts = values[PUSH_ORIGIN]
  if not isDefined(pushAtts) then
    puts "pushing normal"
    # puts `git push`
  else
    puts "pushing origin #{branch}"
    # puts `git push origin #{branch}`
  end
end

def pushAtts(args, index, configFile)
  if args.length == 1 then
    showPushAttsWithNoAttsError()
  end

  args[1..-1].each do |value|
    value_spl = value.split("=")
    if value_spl.length == 1 then showPushAttsWithNoAttsError end
    case value_spl[0]
    when "--o"
      writeToFileOrOverwrite(configFile, PUSH_ORIGIN, "#{PUSH_ORIGIN}=#{value_spl[1]}")
    end
  end
end

def showPushAttsWithNoAttsError()
  puts "Error: trying to add a configuration for push but no attributes are found."
  puts "To add a configuration for push, do use \"git-fast -p --o=<branch-name>\"."
  puts "This is the equivalent of \"git push origin branch-name\"."
  exit(128)
end

def isDefined(val)
  val != nil
end

def alwaysAddAll(configFile)
  writeToFileOrOverwrite(configFile, ADD, "#{ADD}=#{ALL}")
end

def getKeyFromFlag(flag)
  if not isConfigurable(flag) then
    puts "Error: configuration for #{flag} cannot be removed."
    puts "The flag #{flag} is non configurable or does not exist."
    exit(128)
  end
  case flag
  when "-l"
    LOGGED
  when "-p"
    PUSH_ORIGIN
  when "-a"
    ADD
  end
end

def isConfigurable(flag)
  flag == "-l" or flag == "-p" or flag == "-a"
end

configFile = nil
# create configuration file if it doesnt exist
if not File.exist?(CONFIG_FILE) then
  configFile = File.open(CONFIG_FILE, "w+")
else
  configFile = File.open(CONFIG_FILE, "r+")
end

ARGV.each_with_index do |arg, index|
  case arg
  when "-l"
    handleLog(ARGV, index, configFile)
  when "-c"
    commit(ARGV, index, configFile)
  when "-p"
    pushAtts(ARGV, index, configFile)
  when "-pf"
    # force push, no addition of attributes, with attributes from config file
    push(ARGV, index, configFile)
  when "-cpf"
    commit(ARGV, index, configFile)
    push(ARGV, index, configFile)
  when "-r"
    removeConfig(ARGV, index, configFile)
    exit(0)
  when "status", "-s"
    showStatus(configFile)
  when "-a"
    alwaysAddAll(configFile)
  end
end

configFile.close
